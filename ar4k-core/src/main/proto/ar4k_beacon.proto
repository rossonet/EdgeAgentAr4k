// Copyright 2015 The gRPC Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
syntax = "proto3";

option java_multiple_files = true;
option java_package = "org.ar4k.agent.tunnels.http.grpc.beacon";
option java_outer_classname = "BeaconMirrorService";
option objc_class_prefix = "AR4K";

package beacon;

service RpcServiceV1 {
  // for agent registration
  rpc Register (RegisterRequest) returns (RegisterReply) {}
  rpc GetConfigTarget (Agent) returns (ConfigReply) {}
  rpc Polling (Agent) returns (FlowMessage) {}
  rpc Subscription (Agent) returns (stream FlowMessage) {}
  rpc SendChatMessage (ChatMessage) returns (StatusReply) {}
  rpc SendCommandReply (CommandReplyRequest) returns (StatusReply) {}
  rpc SendHealth (HealthRequest) returns (StatusReply) {}
  rpc SendLog (LogRequest) returns (StatusReply) {}
  rpc SendException (ExceptionRequest) returns (StatusReply) {}
  rpc OpenBidirectionalSocketTunnel (stream StreamData) returns (stream StreamData) {}
  // for console
  // list agents connected 
  rpc ListAgents (Empty) returns (ListAgentsReply) {}
  // TODO gestione ssl con Beacon
  rpc ListSslAuthorities (Empty) returns (ListSslAuthoritiesReply) {}
  rpc AddSslAuthorities (SslAuthority) returns (StatusReply) {}
  rpc DropSslAuthorities (SslAuthority) returns (StatusReply) {}
   // TODO gestione kick agent con Beacon
  rpc KickAgent (Agent) returns (StatusReply) {}
  // RPC on agent
  rpc ElaborateMessage(ElaborateMessageRequest) returns (ElaborateMessageReply) {}
  rpc ListCommands(ListCommandsRequest) returns (ListCommandsReply) {}
  rpc CompleteCommand(CompleteCommandRequest) returns (CompleteCommandReply) {}
  // TODO network tunnels 
  rpc CreateProxySocksOnAgent(CreateProxySocksOnAgentRequest) returns (TunnelCreatedReply) {}
  rpc ExposeAgentPort(ExposeAgentPortRequest) returns (TunnelCreatedReply) {}
  rpc ListTunnels (Empty) returns (ListTunnelsReply) {}
  rpc CloseTunnel (CloseTunnelRequest) returns (StatusReply) {}
}

message RegisterRequest {
  string name = 1;
  string secretKey = 2;
  Timestamp time = 3;
  string jsonHealth = 4;
}

message Timestamp {
  // Represents seconds of UTC time since Unix epoch
  // 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
  // 9999-12-31T23:59:59Z inclusive.
  int64 seconds = 1;
  // Non-negative fractions of a second at nanosecond resolution. Negative
  // second values with fractions must still have non-negative nanos values
  // that count forward in time. Must be from 0 to 999,999,999
  // inclusive.
  int32 nanos = 2;
}

message RegisterReply {
  Status result = 1;
  string registerCode = 2;
  int32 monitoringFrequency = 3;
  AnimaStates targetState = 4;
}

message StatusReply {
  Status status = 1;
}

enum Status {
  UNKNOWN = 0;
  GOOD = 1;
  BAD = 2;
  FAULT = 3;
}

enum AnimaStates {
    INIT = 0;
    STARTING = 1;
    STAMINAL = 2;
    CONFIGURED = 3;
    RUNNING = 4;
    SERVICE = 5;
    CONSOLE = 6;
    LAMBDA = 7;
    BOT = 8;
    PAUSED = 9;
    STOPED = 10;
    KILLED = 11;
    FAULTED = 12;
    STASIS = 13;
 }
 
message Agent {
  string agentUniqueName = 1;
  //string hardwareInfoAsJson = 2;
  string secretKey = 2;
  int32 pollingFrequency = 3;
  int64 timestampRegistration = 4;
}
 
message ConfigReply {
  string config = 1;
}

message FlowMessage {
  repeated RequestToAgent toDoList = 1;
}

message RequestToAgent {
  CommandType type = 1;
  Agent caller = 2;
  string uniqueIdRequest = 3;
  string request = 4;
}

enum CommandType {
  ELABORATE_MESSAGE_COMMAND = 0;
  LIST_COMMANDS = 1;
  COMPLETE_COMMAND = 2;
  OPEN_PROXY_SOCKS = 3;
  EXPOSE_PORT = 4;
}

message ChatMessage {
  Agent agentSender = 1;
  Agent agentDestination = 2;
  string messageTxt = 3;
}

message CommandReplyRequest {
  string uniqueIdRequest = 1;
  Agent agentSender = 2;
  Agent agentDestination = 3;
  repeated string replies = 4;
  repeated string errors = 5;
}

message HealthRequest {
  Agent agentSender = 1;
  string hardwareInfo = 2;
}

message LogRequest {
  Agent agentSender = 1;
  LogSeverity severity = 2;
  string logLine = 3;
}

enum LogSeverity {
  // (0) The log entry has no assigned severity level.
  DEFAULT = 0;
  // (100) Debug or trace information.
  DEBUG = 100;
  // (200) Routine information, such as ongoing status or performance.
  INFO = 200;
  // (300) Normal but significant events, such as start up, shut down, or
  // a configuration change.
  NOTICE = 300;
  // (400) Warning events might cause problems.
  WARNING = 400;
  // (500) Error events are likely to cause problems.
  ERROR = 500;
  // (600) Critical events cause more severe problems or outages.
  CRITICAL = 600;
  // (700) A person must take an action immediately.
  ALERT = 700;
  // (800) One or more systems are unusable.
  EMERGENCY = 800;
}

message ExceptionRequest {
  Agent agentSender = 1;
  string messageException = 2;
  string stackTraceException = 3;
}

message StreamData {
  Agent fromAgent = 1;
  Agent toAgent = 2;
  bytes data = 3;
}

message Empty {
}

message ListAgentsReply {
  Status result = 1;
  repeated Agent agents = 2;
}

message ListSslAuthoritiesReply {
  Status result = 1;
  repeated SslAuthority authorities = 2;
}

message SslAuthority {
  string label = 1;
  string description = 2;
  string authorityCa = 3;
}

message ElaborateMessageRequest {
  Agent agentTarget = 1;
  Agent agentSender = 2;
  string commandMessage = 3;
}

message ElaborateMessageReply {
  string reply = 1;
  repeated string errors = 2;
}

message ListCommandsRequest {
  Agent agentTarget = 1;
  Agent agentSender = 2;
}

message ListCommandsReply {
  repeated Command commands = 1;
}

message Command {
  Agent agentSender = 1;
  string command = 2;
  string group = 3;
  string help = 4;
}

message CompleteCommandRequest {
  Agent agentTarget = 1;
  Agent agentSender = 2;
  string commandMessageToComplete = 3;
}

message CompleteCommandReply {
  string reply = 1;
  repeated string errors = 2;
}

message CreateProxySocksOnAgentRequest {
  Agent agentTarget = 1;
  Agent agentSender = 2;
  map<string, string> parameters = 3;
}

message TunnelCreatedReply {
   string uniqueTunnelId = 1;
   Status status = 2;
   Tunnel tunnel = 3;
}

message ExposeAgentPortRequest {
  Agent agentTarget = 1;
  Agent agentSender = 2;
  map<string, string> parameters = 3;
}

message Tunnel {
  string uniqueTunnelId = 1;
  Agent agentFrom = 2;
  Agent agentTo = 3;
  TunnelType type = 4;
  map<string, string> parameters = 5;
}

enum TunnelType {
  EXPOSE_TCP_PORT = 0;
  GRANT_SOCKS_ACCESS = 1;
}

message ListTunnelsReply {
  repeated Tunnel tunnels = 1;
}

message CloseTunnelRequest {
  Agent agentTarget = 1;
  Agent agentSender = 2;
  string uniqueTunnelId = 3;
}

// NOT USED

message Color {
  float red = 1;
  float green = 2;
  float blue = 3;
  float alpha = 4;
}

message Date {
  int32 year = 1;
  int32 month = 2;
  int32 day = 3;
}

message DateTime {
  Date date = 1;
  TimeOfDay time = 2;
}

enum DayOfWeek {
  DAY_OF_WEEK_UNSPECIFIED = 0;
  MONDAY = 1;
  TUESDAY = 2;
  WEDNESDAY = 3;
  THURSDAY = 4;
  FRIDAY = 5;
  SATURDAY = 6;
  SUNDAY = 7;
}

message LatLng {
  // The latitude in degrees. It must be in the range [-90.0, +90.0].
  double latitude = 1;
  // The longitude in degrees. It must be in the range [-180.0, +180.0].
  double longitude = 2;
}

message Money {
  // The 3-letter currency code defined in ISO 4217.
  string currency_code = 1;
  // The whole units of the amount.
  // For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
  int64 units = 2;
  // Number of nano (10^-9) units of the amount.
  // The value must be between -999,999,999 and +999,999,999 inclusive.
  // If `units` is positive, `nanos` must be positive or zero.
  // If `units` is zero, `nanos` can be positive, zero, or negative.
  // If `units` is negative, `nanos` must be negative or zero.
  // For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
  int32 nanos = 3;
}

message PostalAddress {
  // The schema revision of the `PostalAddress`.
  // All new revisions **must** be backward compatible with old revisions.
  int32 revision = 1;
  // Required. CLDR region code of the country/region of the address. This
  // is never inferred and it is up to the user to ensure the value is
  // correct. See http://cldr.unicode.org/ and
  // http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
  // for details. Example: "CH" for Switzerland.
  string region_code = 2;
  // Optional. BCP-47 language code of the contents of this address (if
  // known). This is often the UI language of the input form or is expected
  // to match one of the languages used in the address' country/region, or their
  // transliterated equivalents.
  // This can affect formatting in certain countries, but is not critical
  // to the correctness of the data and will never affect any validation or
  // other non-formatting related operations.
  //
  // If this value is not known, it should be omitted (rather than specifying a
  // possibly incorrect default).
  //
  // Examples: "zh-Hant", "ja", "ja-Latn", "en".
  string language_code = 3;
  // Optional. Postal code of the address. Not all countries use or require
  // postal codes to be present, but where they are used, they may trigger
  // additional validation with other parts of the address (e.g. state/zip
  // validation in the U.S.A.).
  string postal_code = 4;
  // Optional. Additional, country-specific, sorting code. This is not used
  // in most regions. Where it is used, the value is either a string like
  // "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
  // alone, representing the "sector code" (Jamaica), "delivery area indicator"
  // (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
  string sorting_code = 5;
  // Optional. Highest administrative subdivision which is used for postal
  // addresses of a country or region.
  // For example, this can be a state, a province, an oblast, or a prefecture.
  // Specifically, for Spain this is the province and not the autonomous
  // community (e.g. "Barcelona" and not "Catalonia").
  // Many countries don't use an administrative area in postal addresses. E.g.
  // in Switzerland this should be left unpopulated.
  string administrative_area = 6;
  // Optional. Generally refers to the city/town portion of the address.
  // Examples: US city, IT comune, UK post town.
  // In regions of the world where localities are not well defined or do not fit
  // into this structure well, leave locality empty and use address_lines.
  string locality = 7;
  // Optional. Sublocality of the address.
  // For example, this can be neighborhoods, boroughs, districts.
  string sublocality = 8;
  // Unstructured address lines describing the lower levels of an address.
  //
  // Because values in address_lines do not have type information and may
  // sometimes contain multiple values in a single field (e.g.
  // "Austin, TX"), it is important that the line order is clear. The order of
  // address lines should be "envelope order" for the country/region of the
  // address. In places where this can vary (e.g. Japan), address_language is
  // used to make it explicit (e.g. "ja" for large-to-small ordering and
  // "ja-Latn" or "en" for small-to-large). This way, the most specific line of
  // an address can be selected based on the language.
  //
  // The minimum permitted structural representation of an address consists
  // of a region_code with all remaining information placed in the
  // address_lines. It would be possible to format such an address very
  // approximately without geocoding, but no semantic reasoning could be
  // made about any of the address components until it was at least
  // partially resolved.
  //
  // Creating an address only containing a region_code and address_lines, and
  // then geocoding is the recommended way to handle completely unstructured
  // addresses (as opposed to guessing which parts of the address should be
  // localities or administrative areas).
  repeated string address_lines = 9;
  // Optional. The recipient at the address.
  // This field may, under certain circumstances, contain multiline information.
  // For example, it might contain "care of" information.
  repeated string recipients = 10;
  // Optional. The name of the organization at the address.
  string organization = 11;
}

message TimeOfDay {
  // Hours of day in 24 hour format. Should be from 0 to 23. An API may choose
  // to allow the value "24:00:00" for scenarios like business closing time.
  int32 hours = 1;
  // Minutes of hour of day. Must be from 0 to 59.
  int32 minutes = 2;
  // Seconds of minutes of the time. Must normally be from 0 to 59. An API may
  // allow the value 60 if it allows leap-seconds.
  int32 seconds = 3;
  // Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
  int32 nanos = 4;
}